(function(d,u){typeof exports=="object"&&typeof module<"u"?u(exports):typeof define=="function"&&define.amd?define(["exports"],u):(d=typeof globalThis<"u"?globalThis:d||self,u(d["planka-client"]={}))})(this,function(d){"use strict";class u extends Error{constructor(e,r,n){super(n),this.name="ApiError",this.url=r.url,this.status=r.status,this.statusText=r.statusText,this.body=r.body,this.request=e}}class m extends Error{constructor(e){super(e),this.name="CancelError"}get isCancelled(){return!0}}class E{constructor(e){this._isResolved=!1,this._isRejected=!1,this._isCancelled=!1,this.cancelHandlers=[],this.promise=new Promise((r,n)=>{this._resolve=r,this._reject=n;const s=a=>{this._isResolved||this._isRejected||this._isCancelled||(this._isResolved=!0,this._resolve&&this._resolve(a))},i=a=>{this._isResolved||this._isRejected||this._isCancelled||(this._isRejected=!0,this._reject&&this._reject(a))},o=a=>{this._isResolved||this._isRejected||this._isCancelled||this.cancelHandlers.push(a)};return Object.defineProperty(o,"isResolved",{get:()=>this._isResolved}),Object.defineProperty(o,"isRejected",{get:()=>this._isRejected}),Object.defineProperty(o,"isCancelled",{get:()=>this._isCancelled}),e(s,i,o)})}get[Symbol.toStringTag](){return"Cancellable Promise"}then(e,r){return this.promise.then(e,r)}catch(e){return this.promise.catch(e)}finally(e){return this.promise.finally(e)}cancel(){if(!(this._isResolved||this._isRejected||this._isCancelled)){if(this._isCancelled=!0,this.cancelHandlers.length)try{for(const e of this.cancelHandlers)e()}catch(e){console.warn("Cancellation threw an error",e);return}this.cancelHandlers.length=0,this._reject&&this._reject(new m("Request aborted"))}}get isCancelled(){return this._isCancelled}}class T{constructor(){this._fns=[]}eject(e){const r=this._fns.indexOf(e);r!==-1&&(this._fns=[...this._fns.slice(0,r),...this._fns.slice(r+1)])}use(e){this._fns=[...this._fns,e]}}const h={BASE:process.env.PLANKA_URL,CREDENTIALS:"include",ENCODE_PATH:void 0,HEADERS:void 0,PASSWORD:void 0,TOKEN:void 0,USERNAME:void 0,VERSION:"1.0.0",WITH_CREDENTIALS:!1,interceptors:{request:new T,response:new T}},f=t=>typeof t=="string",b=t=>f(t)&&t!=="",R=t=>t instanceof Blob,_=t=>t instanceof FormData,g=t=>{try{return btoa(t)}catch{return Buffer.from(t).toString("base64")}},C=t=>{const e=[],r=(s,i)=>{e.push(`${encodeURIComponent(s)}=${encodeURIComponent(String(i))}`)},n=(s,i)=>{i!=null&&(i instanceof Date?r(s,i.toISOString()):Array.isArray(i)?i.forEach(o=>n(s,o)):typeof i=="object"?Object.entries(i).forEach(([o,a])=>n(`${s}[${o}]`,a)):r(s,i))};return Object.entries(t).forEach(([s,i])=>n(s,i)),e.length?`?${e.join("&")}`:""},A=(t,e)=>{const r=t.ENCODE_PATH||encodeURI,n=e.url.replace("{api-version}",t.VERSION).replace(/{(.*?)}/g,(i,o)=>{var a;return(a=e.path)!=null&&a.hasOwnProperty(o)?r(String(e.path[o])):i}),s=t.BASE+n;return e.query?s+C(e.query):s},j=t=>{if(t.formData){const e=new FormData,r=(n,s)=>{f(s)||R(s)?e.append(n,s):e.append(n,JSON.stringify(s))};return Object.entries(t.formData).filter(([,n])=>n!=null).forEach(([n,s])=>{Array.isArray(s)?s.forEach(i=>r(n,i)):r(n,s)}),e}},p=async(t,e)=>typeof e=="function"?e(t):e,w=async(t,e)=>{const[r,n,s,i]=await Promise.all([p(e,t.TOKEN),p(e,t.USERNAME),p(e,t.PASSWORD),p(e,t.HEADERS)]),o=Object.entries({Accept:"application/json",...i,...e.headers}).filter(([,a])=>a!=null).reduce((a,[l,c])=>({...a,[l]:String(c)}),{});if(b(r)&&(o.Authorization=`Bearer ${r}`),b(n)&&b(s)){const a=g(`${n}:${s}`);o.Authorization=`Basic ${a}`}return e.body!==void 0&&(e.mediaType?o["Content-Type"]=e.mediaType:R(e.body)?o["Content-Type"]=e.body.type||"application/octet-stream":f(e.body)?o["Content-Type"]="text/plain":_(e.body)||(o["Content-Type"]="application/json")),new Headers(o)},I=t=>{var e,r;if(t.body!==void 0)return(e=t.mediaType)!=null&&e.includes("application/json")||(r=t.mediaType)!=null&&r.includes("+json")?JSON.stringify(t.body):f(t.body)||R(t.body)||_(t.body)?t.body:JSON.stringify(t.body)},P=async(t,e,r,n,s,i,o)=>{const a=new AbortController;let l={headers:i,body:n??s,method:e.method,signal:a.signal};t.WITH_CREDENTIALS&&(l.credentials=t.CREDENTIALS);for(const c of t.interceptors.request._fns)l=await c(l);return o(()=>a.abort()),await fetch(r,l)},U=(t,e)=>{if(e){const r=t.headers.get(e);if(f(r))return r}},N=async t=>{if(t.status!==204)try{const e=t.headers.get("Content-Type");if(e){const r=["application/octet-stream","application/pdf","application/zip","audio/","image/","video/"];if(e.includes("application/json")||e.includes("+json"))return await t.json();if(r.some(n=>e.includes(n)))return await t.blob();if(e.includes("multipart/form-data"))return await t.formData();if(e.includes("text/"))return await t.text()}}catch(e){console.error(e)}},O=(t,e)=>{const n={400:"Bad Request",401:"Unauthorized",402:"Payment Required",403:"Forbidden",404:"Not Found",405:"Method Not Allowed",406:"Not Acceptable",407:"Proxy Authentication Required",408:"Request Timeout",409:"Conflict",410:"Gone",411:"Length Required",412:"Precondition Failed",413:"Payload Too Large",414:"URI Too Long",415:"Unsupported Media Type",416:"Range Not Satisfiable",417:"Expectation Failed",418:"Im a teapot",421:"Misdirected Request",422:"Unprocessable Content",423:"Locked",424:"Failed Dependency",425:"Too Early",426:"Upgrade Required",428:"Precondition Required",429:"Too Many Requests",431:"Request Header Fields Too Large",451:"Unavailable For Legal Reasons",500:"Internal Server Error",501:"Not Implemented",502:"Bad Gateway",503:"Service Unavailable",504:"Gateway Timeout",505:"HTTP Version Not Supported",506:"Variant Also Negotiates",507:"Insufficient Storage",508:"Loop Detected",510:"Not Extended",511:"Network Authentication Required",...t.errors}[e.status];if(n)throw new u(t,e,n);if(!e.ok){const s=e.status??"unknown",i=e.statusText??"unknown",o=(()=>{try{return JSON.stringify(e.body,null,2)}catch{return}})();throw new u(t,e,`Generic Error: status: ${s}; status text: ${i}; body: ${o}`)}},y=(t,e)=>new E(async(r,n,s)=>{try{const i=A(t,e),o=j(e),a=I(e),l=await w(t,e);if(!s.isCancelled){let c=await P(t,e,i,a,o,l,s);for(const H of t.interceptors.response._fns)c=await H(c);const D=await N(c),v=U(c,e.responseHeader),S={url:i,ok:c.ok,status:c.status,statusText:c.statusText,body:v??D};O(e,S),r(S.body)}}catch(i){n(i)}});class q{static getUsers(){return y(h,{method:"GET",url:"/users",errors:{404:"User not found"}})}static createUser(e){return y(h,{method:"GET",url:"/users",body:e.requestBody,errors:{404:"User not found"}})}static getUser(e){return y(h,{method:"GET",url:"/users/{userId}",path:{userId:e.userId},errors:{401:"Unauthorized",404:"User not found"}})}static updateUser(e){return y(h,{method:"POST",url:"/users/{userId}",path:{userId:e.userId},body:e.requestBody,errors:{400:"Invalid request body",401:"Unauthorized",404:"User not found"}})}static deleteUser(e){return y(h,{method:"GET",url:"/users/{userId}",path:{userId:e.userId},errors:{401:"Unauthorized",404:"User not found"}})}}d.ApiError=u,d.CancelError=m,d.CancelablePromise=E,d.OpenAPI=h,d.PlankaService=q,Object.defineProperty(d,Symbol.toStringTag,{value:"Module"})});
